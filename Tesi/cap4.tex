\chapter{Soluzioni basso livello}

In questo capitolo procederemo ad una disamina delle scelte tecniche fatte nel progetto darkcloud, e illustreremo il funzionamento dettagliato delle procedure.

\section{Linguaggi di programmazione e ambiente di sviluppo}
\begin{figure}
\begin{center}
\includegraphics[width=15.3cm]{img/logo.png}
\end{center}
\end{figure}
Il linguaggio con il quale è stato scritto darkcloud è Java\cite{java}. La scelta è stata orientata verso questo linguaggio dopo considerazioni fatte sulla complessità del codice di cui si necessitava. Infatti dato che abbiamo optato per un software dove le chiavi di decriptazione, le informazioni su tutti i file, i dati degli altri nodi e molti altri dati sensibili sono salvati in locale si rendeva necessario adottare nel software forti mezzi per mantenere in sicurezza queste informazioni. In java gli strumenti per criptare sono di facile utilizzo. Inoltre anche le connessioni e la formattazione dei messaggi scambiati tra nodi risultava molto semplificata grazie alle classi già disponibili. Dato che si doveva costruire da zero una piattaforma per gestire una rete e questa avrebbe avuto bisogno di un codice molto articolato e con elementi con metodi simili ma caratterizzazioni diverse, ha reso java una scelta preferibile. Il software che realizzavamo doveva poi essere in grado di essere eseguito su piattaforme di diverso tipo, in quanto non solo i professionisti che lo usano potrebbero eseguirlo su sistemi operativi diversi, ma visto che ne saranno usate istanze su cloud computing e facile che lo si eseguirà in queste ultime su sistemi linux.
Oltre al linguaggio java nel software utilizziamo l'sql per salvare i dati. In particolare abbiamo utilizzato il client sqlite3, dato che il nostro software deve salvare informazioni su molti altri nodi, su ogni file , e per ogni file sui frammenti è indispensabile un linguaggio di gestione database multi piattaforma e stabile come l'sql.
Una scelta ormai assodata del gruppo di lavoro del professor Colajanni è l'utilizzo del sistema operativo Debian per la fase di sviluppo del software. Tale sistema operativo infatti garantisce nelle release stable la sicurezza di lavorare su un sistema molto stabile e nella comunità degli sviluppatori molto sfruttato. Essendo usato molto dai programmatori gli strumenti di compilazione, debug, e gli ambienti di sviluppo per programmare sono stati testati a lungo e quindi arrivati ad un buon livello di stabilità. Essendo sicuri che non darà spiacevoli sorprese in corso di programmazione. 
L'ambiente di sviluppo java utilizzato è stato Eclipse. Gli strumenti che offre per il lavoro di programmazione sincronizzato lo rendono perfetto per il nostro caso, nel quale io e il correlatore della tesi, l'ingegner Fabio Manganiello, abbiamo lavorato simultaneamente sul codice.
Per sincronizzare il codice abbiamo usato Google Code. Si tratta di un servizio di casa Google gratuito che permette di creare progetti software e consente a diverse persone di lavorarci. Abbiamo infatti installato il plugin Subversion per Eclipse, questo ci ha permesso di impostare il repository per il progetto. In questo modo chi lavora ad una classe può bloccarla direttamente da Eclipse e quando ha finito sbloccarla e caricare i risultati. 
Quindi i requisiti di sistema sono una installazione di Java Runtime Environment versione 1.6.x o maggiore e il client di sqlite3.
\section{Analisi di un nodo}
Per funzionare un nodo, che sia client o server, ha bisogno di alcuni file. 
Il file eseguibile darkcloud.jar, che è lo stesso sia per i client che per i server. Questo eseguibile deve essere avviato sia sui client che sui server. Una volta avviati almeno un client e un server sarà possibile iniziare ad usare il sistema tramite un terminale, potendo salvare file e recuperarli.
Il database darkcloud.db, che contiene tutte le informazioni del nodo. Nel database vengono salvati i dati di tutti i file, i dati dei frammenti dei file e le caratteristiche degli altri nodi presenti in darkcloud.
Il file di configurazione darklcoud.conf, che contiene tutti i setting del nodo. Vi troviamo specificati l'indirizzo ip e la porta di ascolto del nodo locale, il tipo di nodo locale, l'indirizzo ip e le porte degli altri nodi presenti sulla rete con specificato se si tratta di client o server.
Il file darkcloud.keystore, che contiene le chiavi pubbliche degli altri nodi e i certificati ssl. Dato che nella rete utilizziamo connessioni protette SSL ogni nodo deve conoscere la chiave pubblica di ogni altro nodo, oltre a ciò le chiavi pubbliche degli altri nodi sono usate per cifrare i file che gli si mandano.
Infine i file private.key e public.key che contengono le chiavi RSA pubblica e privata del nostro nodo usate per criptare e decriptare le informazioni da e per il nodo.
Se si vuole spostare un nodo su un altro computer sarà sufficiente spostare i file sopra menzionati. Dato che la mappatura dei nodi è contenuta nel file darkcloud.conf dovremmo anche modificare i valori se cambierà l'ip del computer in uso, sia nelle impostazioni locali che nelle liste ip degli altri nodi che devono comunicare con noi.
\section{Gestione dei nodi}
Per gestire i nodi sono stati creati una serie di script che permettono di eseguire le funzioni fondamentali per il funzionamento della rete. Sono script da usare solo per modifiche da parte di amministratori della rete, gli utilizzatori finali non si troveranno mai a doverli usare dovranno solo interagire con i terminali. Questi script si possono trovare nella sotto directory 'net' e sono:
\begin{itemize}
	\item createNode.sh 
	\item removeNode.sh
	\item startNet.sh
	\item stopNet.sh
	\item startNode.sh
	\item stopNode.sh
\end{itemize}
Lo script createNode.sh permette di creare dei nodi, i parametri richiesti quando viene avviato sono: nome del nodo, tipo di nodo che può essere client o server, porta di ascolto, keystore password, nome e cognome, nome dell'unità aziendale, nome dell'azienda, località, provincia, codice a due lettere del paese in cui si trova l'unità. Al temine della configurazione lo script controlla se sono già stati creati altri nodi. Successivamente ci viene chiesto se vogliamo che i certificati degli altri nodi che sono stati trovati siano marcare come fidati, questo è necessario se vogliamo essere in grado di comunicare con essi. Al termine di questa operazione della sotto directory 'net' avremo una cartella che si chiama come il nostro nodo contenente i file necessari al suo funzionamento.
Le impostazioni precedentemente inserite vengono salvate nel file di configurazione del nodo chiamato darkcloud.conf . Se in seguito alla creazione si vuole apportare modifiche al nodo basterà andare nella directory 'net', nella sotto directory che si chiama come il nodo e modificare tale file. 
In particolare di default tutti i nodi conosciuti e certificati della rete hanno 127.0.0.1 come indirizzo ip. Se si vuole spostare questi nodi su altre macchine collegate ad internet, basta poi modificare i file darkcloud.conf di tutti i nodi della rete.
Infatti la conoscenza che un nodo ha degli altri è specificata in tale file, quindi se la geografia della rete viene cambiata deve essere aggiornata in ogni nodo della rete. 
Lo script removeNode.sh ci permette di disinstallare il nodo dalla macchina locale, e si occupa anche di rimuovere da eventuali altri nodi presenti nella cartella le specifiche del nodo rimosso.
Con lo script startNet.sh possiamo avviare tutti i nodi presenti nella directory 'net'. Se invece si vogliono avviare dei nodi singolarmente si utilizzerà lo script startNode.sh. 
Quando un nodo viene avviato in una cartella nascosta che si chiama .run vengono creati dei file nel formato 'nome nodo'.pid nei quali vengono salvati i pid dei nodi avviati. Questo serve per evitare di aprire più istanze dello stesso nodo, azione che porterebbe a problemi sul database e alla gestione delle risorse. Al loro avvio gli script di avvio della rete o dei nodi controllano che nella cartella .run non ci siano già i pid dei nodi che si tenta di avviare. Inoltre gli script di avvio controllano che all'interno della cartella del nodo siano presenti l'eseguibile e il file di configurazione per evitare errori.
Analogo discorso per lo script stopNet.sh tramite il quale possiamo spegnere tutti i nodi presenti nella directory 'net'. Mentre se si vuole spegnere un singolo nodo si utilizzerà lo script stopNode.sh. Oltre a inviare il segnale di kill del processo gli script di arresto cancellano dalla cartella .run i pid dei processi.
\section{Gli oggetti Darkcloud e NetNode}
Quando noi avviamo l'eseguibile di darkcloud, il main crea una istanza della classe Darkcloud e una della classe NetService. Darkcloud è la classe principale di ogni nodo, che contiene le variabili con le chiavi per la criptazione, le liste con i dati degli altri nodi, il collegamento con il database e altro ancora. NetService invece è la classe che prende i dati di ip e porta di ascolto del nostro nodo e crea il socket ssl che viene usato in ascolto. A seconda che un nodo sia client o server poi viene creata una istanza di ServerService o ClientService, che rimangono in ascolto di connessioni in entrata e in caso arrivino richieste istanziano a loro volta le classi Client o Server che si occupano di leggere il messaggio in arrivo e decifrare di che tipo di richiesta si tratta, invocando poi il giusto metodo di risposta delle classi ServerResponseMethod o ClientResponseMethod. Queste ultime due classi contengono il codice che un nodo esegue in risposta ad una richiesta. I dettagli del codice eseguito nei diversi comandi verrà analizzato nel paragrafo dedicato ai comandi. Le diverse richieste sono elencate all'interno della classe Request.java, che modella le richieste che i nodi possono scambiarsi. Attraverso il tipo di Java definito Enum, Enumerazione, possiamo nella classi Request.java definire i diversi tipi di richieste semplicemente specificandone il nome, in modo che nelle classi ServerResponseMethods.java e ClientResponseMethods.java andiamo a indicare il codice da eseguire a seconda della richiesta ricevuta.
Se si vuole aggiungere un comando basta aggiungerlo alla lista lista in Request.java e scriverne il codice nella classe di risposta del client o del server.

La classe Darkcloud contiene due paricolari hashmap, chiamati clientNodes e serverNodes. Una hashmap è una collezione di oggetti, che memorizza coppie chiave-valore, dove la chiave serve come indice. clientNodes e serverNodes infatti sono composti da oggetti di tipo NetNode e chiavi di tipo stringa. Gli oggetti NetNode sono istanze della classe omonima e vengono create come immagini degli altri nodi della rete, utilizzate quindi dalla classe Darkcloud come interfacce per comunicare con gli altri nodi.
La classe clientService oltre ad aspettare le connessioni in arrivo crea all'avvio un istanza della classe NetPoll. Questa classe viene fatta partire all'inizio del programma e rimane attiva sempre fino a quando non viene terminato il programma, il suo compito è quello di controllare periodicamente quali nodi sono vivi e quali no. Fa questo inviandogli dei messaggi di tipo ping, e in base alla risposta segna gli oggetti NetNode come online o offline all'interno della struttura clientNodes e serverNodes. 
La classe NetNode possiede un metodo che si chiama send. Questo metodo viene invocato dal nostro programma quando ha bisogno di inviare informazioni a un altro nodo. 
Il metodo send accetta in ingresso un oggetto di tipo Request e fornisce in uscita un oggetto di tipo Response. Dato che il nostro nodo costituito dalla classe Darkcloud, ha per ogni altro nodo un oggetto NetNode, all'interno del quale sono contenute le informazioni dell'altro nodo, se vogliamo inviare un messaggio all'altro nodo sarà sufficiente usare il comando NetNode.send. Ora il NetNode si attiverà e il suo metodo send leggerà i suoi dati, creerà una connessione con il nodo remoto che lui rappresenta, gli invierà l'oggetto request che Darkcloud cioè il nodo locale gli vuole mandare, aspetterà la risposta rappresentata da un oggetto response e la restituirà a chi lo ha invocato cioè Darkcloud.
\section{Connessioni}
In questo paragrafo parleremo delle connessioni che instauriamo tra due nodi, tramite i quali scambiamo informazioni. Nel nostro caso specifico abbiamo deciso di utilizzare le connessioni SSL. Le connessioni SSL sono connessioni criptate tramite una chiave pubblica. Quando noi creiamo i nostri nodi, lo script di creazione crea per ogni nodo una coppia di chiavi e un KeyStore. Il KeyStore è un file che contiene tutte le password pubbliche degli altri nodi che appartengono alla rete. Questo KeyStore per sicurezza è a sua volta protetto da una password. Quando il nostro programma viene avviato sappiamo che la prima classe, quella principale, che viene istanziata è Darkcloud. All'interno di questa classe nei comandi di inizializzazione vengono impostate due variabili di sistema di java, javax.net.ssl.keyStore e javax.net.ssl.trustStore. In queste due variabili andiamo a porre la posizione del KeyStore, in modo che quando nel corso del programma andremo a creare un socket SSL java sappia dove può reperire la chiave del nodo che vogliamo contattare e in questo modo creare la connessione protetta.

L'avere una connessione però non è sufficiente a trasferire gli oggetti che noi abbiamo ideato per passare i dati tra una classe e l'altra. Infatti il protocollo SSL trasporta stringhe mentre noi abbiamo bisogno di passare tra nodi diversi molti tipi di informazioni diverse, come numeri interi, byte di dati, date e altro. Per questo ci avvaliamo di una particolare formattazione delle stringhe che poi verranno scritte nei socket. In modo che quando il dato da noi inviato viene ricevuto da un altro nodo lui sappia come interpretarlo e quindi possa estrarne i contenuti informativi. Per formattare i nostri messaggi utilizziamo l'XML. XML è un linguaggio di markup, ovvero un linguaggio che definisce un meccanismo sintattico che ci permette di definire e riconoscere il significato degli elementi contenuti in un testo. 

Quando due classi vogliono scambiarsi informazioni lo fanno essenzialmente tramite l'uso di due oggetto, la request e la response. Request e response sono estensioni della classe message. La differenza tra di loro è che una request deve richiamare un comando, mentre la response deve comunicare se l'operazione è andata bene o male. Dato che i comandi dei nostri nodi sono cinque anche le tipologie di request sono cinque, mentre i tipi di response sono due, risposta positiva o errore.
Il codice degli oggetti request e response ha dei metodi che ci permettono di inserire al loro interno tutte le informazioni che vogliamo, e anche di organizzarle. Tramite il metodo appendField noi possiamo creare un nuovo campo, in questo campo possiamo inserire direttamente dei dati, oppure creare al suo interno degli attributi, tramite il metodo setContent. Quando abbiamo finito di inserire i campi e gli attributi le informazioni all'interno dei nostri oggetti sono pronte per essere spedite. Per fare questo utilizzeremo il metodo delle request e delle response che si chiama toString. Questo metodo prende tutti i dati che abbiamo riposto nel nostro oggetto, che abbiamo organizzato in campi e attributi, e lo converte in messaggi XML dovutamente formattati, sotto questa forma i nostri dati possono viaggiare sul socket SSL.
Una volta ricevuto questo messaggio XML potrà facilmente essere trasformato nell'oggetto originario, request o response che sia. Questo avviene creando un nuovo oggetto request o response e fornendogli il messaggio tramite il metodo fromString. Dato che l'oggetto sa come sono formattai i dati in XML può agilmente convertirli nei campi e negli attributi originali. 
In questi messaggi XML prima di essere spediti viene inserita la lunghezza del messaggio e la firma del mittente. Questo per facilitare la decodifica al metodo ricevente. Più precisamente è un messaggi formattato in 3 righe, nella prima riga cè la lunghezza del messaggio, nella seconda riga il contenuto informativo e nella terza riga la firma del mittente. 

I metodi che gestiscono la scrittura di questo messaggi sui socket sono il send di NetNode e run di CLient.
Quando un nodo vuole mandare un messaggio ad un altro nodo utilizza il metodo send all'interno dell'istanza NetNode che rappresento il nodo ricevente. Mentre il meccanismo di ricezione è basato sulla classe ClientService o ServerService. Queste classi sono continuamente in ascolto e se rilevano un messaggio SSL istanziano Client e gli passano il socket. Sia nel caso del send che del Client per prima cosa si creano due buffer uno per la lettura e uno per la scrittura. Nel send poi si allega alla request il campo nodeid, che comprende il proprio ip e la propria porta di ascolto, in modo che il ricevente abbia sempre i dati per identificare il mittente. 
Si procede poi a scrivere sul buffer uscente il messaggio XML tramite il comando request.toString() di cui abbiamo parlato prima che traduce il contenuto della request in codice XML. 
A questo punto il clientService o il serverService rilevano il messaggio, istanziano Client o Server e gli passano il riferimento al socket. Il Client per prima cosa legge la prima riga passata nel messaggio, che contiene la lunghezza, questo valore gli serve per decifrare il resto del messaggio. Ora legge dal buffer una riga lunga quanto era specificato nella prima riga. Forniamo in ingresso al metodo fromString, di un nuovo oggetto request, la stringa appena letta, i cui valori vengono cosi inseriti nella request stessa. Il Client ora salva in un array tutti i metodi che conosce il client, e poi li confronta con quello della request. Se trova una corrispondenza invoca tale metodo e gli passa l'oggetto request. Come risultato del codice del comando gli viene restituito un oggetto response, che procede a spedire sullo stesso socket dal quale ha letto tramite però un buffer di scrittura. Chiaramente per scriverlo usa il metodo toString dell'oggetto response ricevuto che traduce il contenuto in una stringa. Infine Client chiude i due buffer e il socket. 
Il send riceve il messaggio tramite il socket, chiude il socket, traduce il response con fromString, chiude i buffer e il socket. Procede al controllo dell'esistenza del campo nodeid per verificare l'identità di chi gli ha risposto. Dopo di che controlla anche il campo che contiene la chiave pubblica, e controlla se corrisponde con quella che il nodo ha salvato in corrispondenza di quel nodeid. Se così non è sostituisce la chiave con quella ricevuta. Per concludere restituisce l'oggetto response alla classe che lo aveva invocato. 
\section{Database}
\begin{figure}
\begin{center}
\includegraphics[width=15.3cm]{img/classdiagram.png}
\end{center}
\caption{Class Diagram}
\label{Class Diagram}
\end{figure}
In Darkcloud si fa largo uso di database\cite{database}. I dati mantenuti sul nodo sono molti. Infatti le informazioni sui dati e sugli altri nodi non sono centralizzate o mantenute in remoto, ma sono invece tutte salvate in locale. Ogni nodo, sia client che server, possiede nella cartella principale del programma un database che si chiama darkcloud.db .
Le tabelle principali che contiene sono :
\begin{itemize}
	\item FILE
	\item FILEFRAGMENT
	\item FILEPERMISSION
	\item FILEUPDATE
	\item NODE
	\item NODETYPE
	\item PERMISSIONTYPE
	\item UPDATETYPE
\end{itemize}
Lo schema relaziona del database è riportato di seguito:\\ \\
FILE(\underline{NAME},CONTENT,KEY,CHECKSUM,UPLOADER,CREATIONTIME,\\MODIFYTIME,MODIFYBY)\\
NODETYPE(\underline{NODETYPEID},NODETYPESTR)\\
UPDATETYPE(UPDATETYPEID,UPDATETYPESTR)\\
FILEFRAGMENT(\underline{NAME,FRAGMENTID},CHECKSUM,NODEID)

		\textbf{FK:} NODEID \textbf{REFERENCES} NODE(NODEID)
		
		\textbf{FK:} UPDTYPE \textbf{REFERENCES} UPDATETYPE(UPDATETYPEID)\\
FILEUPDATE(\underline{UPDID},FILENAME,NODEID,UPDTYPE,UPDTIME)

		\textbf{FK:} FILENAME \textbf{REFERENCES} FILE(NAME)
		
		\textbf{FK:} UPDTYPE \textbf{REFERENCES} UPDATETYPE(UPDATETYPEID)\\
NODE(\underline{NODEID},PUBKEY,TYPE,ADDR,PORT)

		\textbf{FK:} TYPE \textbf{REFERENCES} NODETYPE(NODETYPEID)\\
PERMISSIONTYPE(\underline{PERMTYPEID},PERMTYPESTR)\\
FILEPERMISSION(\underline{NODEID,FILENAME},PERM)

		\textbf{FK:} NODEID \textbf{REFERENCES} NODE(NODEID)

		\textbf{FK:} FILENAME \textbf{REFERENCES} FILE(NAME)

		\textbf{FK:} PERM \textbf{REFERENCES} PERMISSION(PERMID)\\
\\
All'interno del codice gli inserimenti e le letture di dati sono frequenti, invece che elencarle qui si preferisce inserirle nelle descrizioni dei comandi riportati di seguito.
\section{Crittografia}
Questo programma fa della crittografia dei dati uno dei suoi punti di forza. Dato che informazioni preziose, che potrebbero essere utilizzare per risalire ai dati, sono salvate in locale si fa un largo uso di tecniche di cifratura. In questo progetto si usano due tipi di cifratura la AES e la RSA. Sono due tipi di cifratura diversi, il primo è simmetrico, il secondo asimmetrico.
L'AES\cite{aes} (Advanced Encryption Standard) conosciuto anche come Rijndael, è l'algoritmo di cifratura a blocchi utilizzata come standard dal governo degli Stati Uniti d'America\cite{federal}. E' una tecnica di cifratura che perfino l'NSA utilizza per cifrare i documenti TOP SECRET. Questa tecnica di cifratura può utilizzare chiavi con lunghezza variabile di 128,192 o 256 bit e lavora con blocchi di dimensione prefissata di 128 bit. La dimensione maggiore della chiave crittografica garantisce una maggior sicurezza. Sono stati fatti dei test nel 2011 per vedere in quanto tempo con due gpu e un metodo di forza bruta si riuscisse a decifrare un file criptato in AES a 256 bit. Il risultato è stato che ci sarebbero voluti circa 13 anni di calcoli. All'interno del nostro programma per una maggior sicurezza infatti usiamo una chiave da 256bit. 

Della cifratura asimmetrica si è già accennato nel capitolo due, il meccanismo è semplice, ogni nodo ha una chiave pubblica e una privata, quella pubblica è scambiata con tutti i nodi e quella privata è mantenuta segreta. Se si cripta un file usando quella pubblica solo quella privata può decifrarlo , in questo modo tutti possono creare messaggi decifrabili solo da chi detiene la chiave privata. Lo standard de facto oggi si basa sulla cifratura RSA\cite{rsa}, un cifrario a chiave pubblica che permette di cifrare un messaggio sfruttando alcune proprietà elementari dei numeri primi. Questo cifrario prende il nome dalle iniziali dei matematici che nel 1976 lo crearono: Rivest, Shamir e Adleman. La loro idea fu quella di sfruttare la difficoltà di fattorizzare un numero intero. Di fatti la chiave pubblica è un numero N ottenuto moltiplicando due numeri primi molto grandi che restano segreti. Come nell'AES anche l'RSA può usare chiavi di grandezza variabile, e anche in questo caso più grandi sono, maggiore è la difficoltà in tentativi di attacchi di forza bruta. Le chiavi possono andare da una dimensione di 1024 ad un massimo di 4096 tipicamente. Spendendo un milione di euro per dotarsi di un cluster potente ci vorrebbero circa sei mesi per decriptare un messaggio criptato con RSA a 768 bit. Alcuni studiosi affermano che le chiavi a 1024 bit saranno scardinabili nel prossimo futuro\cite{rischio}. Infatti oggi la maggior parte dei sistemi usa chiavi a 1024 o 2048. Noi abbiamo deciso per tutelarci di usare chiavi a 4096 bit, che gli studiosi di crittografia credono sarà difficile poter scardinare in base alle previsioni sul futuro dell'informatica. 
La classe CryptUtil presente nel pacchetto Util di Darkcloud è quella nella quale abbiamo inserito i metodi che gestiscono la cifratura. Infatti vi troviamo il metodo generateKeyPair che permette di generare una coppia di chiavi RSA a 4096 bit, il metodo generateSymmetricKey che genera chiavi AES simmetriche da 256 bit, i metodi storePublicKey e storePrivateKey che permettono di memorizzare nei file usati come keystore le chiavi, i metodi getPrivateKey e getPublicKey che specifiando un file restituiscono la chiave contenuta. Poi troviamo alcuni metodi che ci permettono di convertire le chiavi in oggetti diversi, per esempio le chiavi generalmente in java sono utilizzate come oggetti Key o Secretkey però quando abbiamo bisogno di inserire chiavi in un messaggio non possiamo lasciarle in questa forma ma dobbiamo convertirle in stringhe. Questi metodi di conversione sono privKeyToString e pubKeyToString che convertono oggetti Key in stringhe, privKeyFromString e pubKeyFromString che traducono le stringhe in oggetti Key, secretKeyFromString che traduce le stringhe in oggetti SecretKey. Troviamo poi i metodi sign e verifySign che rispettivamente servono per generare e verificare le firme da allegare ai messaggi scambiati tra nodi, firme scritte con le chiavi private e che quindi possono essere decifrate tramite le chiavi pubbliche per verificare l'identità del mittente. Gli ultimi due metodi sono encrypt e decrypt che permettono di criptare o decriptare un array di byte specificando la chiave e il metodo di cifratura. 
I file che troviamo nella cartella principale del nostro nodo che riguardano la cifratura sono fondamentalmente quattro cioè il certificato del nostro nodo ad esempio \begin{verbatim}client_1.crt\end{verbatim}, il keystore darkcloud.keystore del nostro nodo cioè il file che contiene le chiavi pubbliche degli altri nodi che conosciamo e i file private.key e public.key che sono rispettivamente la chiave privata e pubblica del nostro nodo. 

\section{Comandi}
Andremo ora ad analizzare nello specifico quali passaggi avvengono e come vengono elaborati i dati nelle esecuzione dei comandi.
I comandi principali sono PING, PUT, GET e SHARE.
\subsection{Ping}
\begin{figure}
\begin{center}
\includegraphics[width=15.3cm]{img/ping act.png}
\end{center}
\caption{Activity diagram del comando ping}
\label{Activity diagram del comando ping}
\end{figure}

Il metodo ping viene utilizzato principalmente nei terminali per verificare se un nodo client è vivo e nella classe NetPoll che lo usa per tenere aggiornato l'elenco dei server e dei client vivi sulla rete.
La sintassi del comando ping è:

python client.py -r PING -h 'indirizzo ip del client' -p 'porta di ascolto del client'

Il nodo che riceve un messaggio ha sempre in ascolto sul socket SSL la classe ClientService. Questa classe controlla continuamente se sul socket ci siano richieste. Quando ne rileva una crea una istanza della classe Client e gli passa il riferimento al socket. L'istanza di Client legge dal socket il messaggio, legge di che tipo di request si tratta e in questo caso invoca il metodo ping della classe ResponseMethods. ResponseMethods è una generalizzazione che poi viene estesa per creare ClientResponseMethods e ServerResponseMethods. L'istanza di Client passa al metodo ping la request contenuta nel messaggio. Per prima cosa il metodo ping recupera dal messaggio il campo pubkey e il campo nodeid, che contengono rispettivamente la chiave pubblica e il codice identificativo del nodo che gli ha mandato la richiesta . In seguito confrontando il nodeid con quelli salvati nelle strutture clientNodes e serverNodes controlla se è un nodo con il quale può dialogare e se si tratta di un server o di un client. In caso si tratti di un nodo conosciuto confronta la chiave pubblica del messaggio con quella che ha salvato nell'oggetto NetNode corrispondente, in caso sia uguale crea un nuovo oggetto response, gli da l'attributo di tipo ACK cioè di risposta positiva, e lo restituisce all'istanza di Client. L'istanza di Client ricevuto l'oggetto response lo scrive nel socket SSL, lo invia, chiude la connessione e muore.
In questa spiegazione abbiamo parlato solo della richiesta ping nel caso sia ricevuta da un nodo di tipo client, ma a differenza degli altri comandi il ping funziona nello stesso modo sia per i server che per i client. Con l'unica differenza che il client risponde anche se non viene specificata la pubkey e il nodeid, in quanto il client può ricevere richieste anche da terminali che di fatto non possiedono tali caratteristiche.
\subsection{Put}
\begin{figure}
\begin{center}
\includegraphics[width=15.3cm]{img/put act.png}
\end{center}
\caption{Activity diagram del comando put}
\label{Activity diagram del comando put}
\end{figure}

La ricezione del comando put da parte di un client invece innesca una sequenza di azioni che comprendono anche l'interazione con i server. Quindi analizzeremo sia la risposta al comando put di un client che di un server.
La sintassi del comando put è:

python client.py -r PUT -h 'indirizzo ip del client' -p 'porta di ascolto del client' -f 'nome del file locale' -F 'nome da assegnare al file in remoto'

Un utente dalla cartella dove abbiamo lo script che nei nostri test fungeva da terminale, client.py, digita il comando. In questo specifica l'ip e la porta di ascolto del client a lui dedicato, il nome di un file che si trova nella stessa cartella, o specifica prima del nome la posizione, infine il nome con il quale sarà salvato il file dal client. Premuto invio lo script cioè il nostro terminale effettua i controlli necessari sui campi inseriti, controlla se il file è codificato, in caso contario ne legge il contenuto, lo salva e calcola il checksum del file. Crea un messaggio xml, vi aggiunge i campi per il contenuto del file, il nome del file in remoto, il checksum e il tipo di codifica con cui potrebbe essere salvato il file. Dopo di ché crea una connessione in base all'ip e alla porta di ascolto che noi abbiamo specificato e apre un socket SSL tramite il quale invia il messaggio al nostro client. Il nostro client che ha ClientService in ascolto rileva il messaggio, istanzia Client e gli passa il socket. Client legge il messaggio legge il tipo di richiesta e invoca il metodo put della classe ClientResponseMethods passandogli l'oggetto request contenuto nel messaggio.
Il metodo put di ClientResponseMethod legge dall'oggetto request il contenuto del campo file, controllando che non sia vuoto. Recupera anche il nome del file e il tipo di codifica, in caso il file risulti codificato il metodo procede a decifrarlo, dopo di che legge il campo checksum e calcola il checksum del file ricevuto. Paragona il checksum calcolato con quello del messaggio per verificare errori di trasmissione, in caso combacino procede. Ora tramite il metodo getAliveServerNodes della classe Darkcloud recupera una copia dei NetNode che sono vivi e li pone in un hashmap. Ora si rende necessario mescolare l'hashmap in modo che i server a cui si inviano i frammenti non siano tutti consecutivi. Per fare questo creiamo una seconda hashmap con la stessa struttura di quella con i server. Creiamo un array di stringhe e vi salviamo tutte  le chiavi della hashmap dei server. Usiamo la funzione Collections.shuffle(keys) per mescolarne le stringhe e con un ciclo for inseriamo nella seconda hashmap i NetNode usando come di selezione le stringhe mescolate.
A questo punto avremo la seconda hashmap che contiene i NetNode mescolati a dovere. Procediamo con la fase di cifratura del file. 
Generiamo una chiave simmetrica tramite il metodo generateSymmetricKey della classe CryptUtil. Criptiamo il contenuto del file sempre tramite un metodo di CryptUtil che si chiama encrypt. Particolare attenzione va fatta in questi passaggi in quanto nelle comunicazioni tra metodi i byte vanno passati codificati in base 64, inoltre i metodi che criptano vogliono in ingresso byte e non stringhe, maggiori dettagli vengono forniti nei prossimi paragrafi riguardanti la crittografia. 
Giunti a questo punto abbiamo il contenuto del nostro file criptato e contenuto in un array di byte.  
Per sapere quanto grandi devono essere i nostri frammenti prendiamo la dimensione del file criptato e la dividiamo per il numero di server. In questo modo però se la divisione ha del resto andrebbero persi dei byte, quindi aggiungiamo 1 alla dimensione dei frammenti. Tramite un ciclo for andiamo a leggere porzioni del file criptato che vengono poi salvate in un array di stringhe, la lettura parziale avviene tramite la funzione substring che permette di leggere da una stringa un numero dato di caratteri a partire da una posizione a scelta. Ora le parti sono contenute nel nostro array di stringhe. In un ciclo for che si ripete per il numero di server che abbiamo andiamo ad inviare i frammenti. Creiamo prima di tutto un oggetto NetNode e gli andiamo a mettere dentro quello preso dalla hashmap mescolata, in modo da poter dopo usare il metodo send e mandargli un messaggio. Ora calcoliamo il checksum del frammento, prendiamo la request che ci ha mandato il terminale e andiamo ad aggiungergli i campi dove inseriamo il contenuto criptato, il checksum, dato che ci sono ancora i campi creati dal terminale la request contiene anche il nome del file e il nodeid del client. 
Completato l'oggetto request questo viene mandato tramite il metodo send al NetNode preso dalla hashmap mescolata. 

Ora il server riceve tramite la consueta procedura l'oggetto request di tipo put quindi viene invocato il metodo put del ServerResponseMethod. Il metodo put del server legge il contenuto del file e fa il controllo del checksum. Se il checksum corrisponde procede a salvare nel database i dettagli del frammento. I campi che vengono salvati sono nome del file, contenuto del frammento, checksum, nodeid del client, data di creazione e data di modifica. Inoltre dato che viene tenuta traccia anche delle modifiche fatte ai file viene anche inserito un nuovo record nella tabella FILEUPDATE con i dati nome del file, nodeid, tipo di update, e data della modifica. Al termine del metodo se tutto va bene si restituisce un oggetto response di tipo ACK che viene mandato al client.

Quando il client riceve il response di tipo ACK passa al salvataggio nel database dei dettagli di questo frammento nella tabbela FILEFRAGMENT, che comprendono nome del file, un intero che indica il numero del frammento, il checksum e il nodeid del server dove il frammento è salvato. Alla fine di questo ciclo for se tutti i frammento sono stati correttamente inviati il metodo prende la chiave simmetrica usata per criptare il file e la cripta usando la sua chiave pubblica. Poi registra sul database nella tabella FILE i dettagli del file appena splittato sui server, salvandone nome, chiave criptata, checksum, data di creazione e data di modifica. 
\subsection{Get}
Il comando get usato tramite un terminale permette di recuperare un file precedentemente salvato. Come per il comando put questo comando fa eseguire codice diverso a seconda se sia inviato ad un client o ad un server. Nel seguito analizzeremo entrambi.
La sintassi del comando get è:

python client.py -r GET -h 'indirizzo ip del client' -p 'porta di ascolto del client' -F 'nome del file in remoto'

Quando un utente vuole recuperare un file che ha salvato in darkcloud sarà sufficiente che usi il comando get, il codice che ci sta dietro recupererà i frammenti, decripterà il contenuto e darà in uscita il contenuto del file. Ma procediamo a vedere nei dettagli cosa accade nel codice.
Il terminale come nel caso del ping e del put creerà un messaggio xml e al suo interno metterà il nome del file da recuperare, i dati del nodo client che intende usare per recuperarlo. Dopo di che creerà un socket SSL e invierà al nodo client che voi avete specificato, e che è l'unico che un utente deve usare per recuperare i suoi file, il messaggio. Il ClientService sempre in ascolto rileverà il messaggio, creerà in istanza di Client e gli passerà il socket. Client leggerà il messaggio, recupererà il tipo di request contenuta al suo interno e invocherà il metodo corrispondente del ClientResponseMethods, nel nostro caso il metodo get.
Il metodo prende in ingresso un oggetto request, e inizia leggendo il campo file e verificando che non sia vuoto. Poi passa a leggere all'interno del campo file l'attributo name,cioè il nome del file, e controlla che anche esso non sia nullo. Fatti tali controlli il metodo fa un join sulle tabelle FILE e FILEFRAGMENT sulla colonna name, dove il valore name è uguale al nome passato nella request. Leggendo poi in tale ordine la chiave di decriptazione, il fragmentid cioè il numero del frammento, il checksum del frammento e il nodeid dove il frammento è salvato. Ordinando i risultati per fragmentid. Se la query restituisce risultati il passo successivo è decriptare la chiave. Tramite il metodo decrypt della classe Cryptutil specificando la chiave da decriptare, la propria chiave privata recuperata tramite il metodo getPrivateKey di Darkcloud e infine il tipo di cifratura nel caso RSA, otterremo la chiave simmetrica del file in chiaro sotto forma di stringa. Visto che però per decifrare il file tramite il metodo decrypt dopo averlo ricomposto dovremo specificare la chiave sotto forma di oggetto Secretkey, la convertiamo subito da stringa a Secretkey tramite il metodo secretKeyFromString della classe CryptUtil. A questo punto tramite un ciclo for andiamo a ripetere le prossime operazioni per il numero di record restituiti dal join. Prendiamo il primo nodeid restituito dal join e copiamo l'oggetto NetNode che gli corrisponde in una istanza locale. Possiamo farlo tramite il metodo getAliveServerNodes().get(nodeid). Ora abbiamo il NetNode pronto per quando dovremo inviare una request al server. Creiamo un oggetto request, impostiamo l'attributo tipo come get e gli aggiungiamo un nuovo campo nominandolo file, al quale poi aggiungiamo l'attributo name. Attribuiamo a name il nome del file ed inviamo al server questa request tramite il metodo send dell'oggetto NetNode che abbiamo prima recuperato. 

Ora il server riceverà la nostra richiesta, leggerà dall'attributo name del campo field dell'oggetto request il nome del file. Tramite una select sulla sua tabella FILE, in base al nome recupererà i seguenti campi: contenuto, checksum, data di creazione, data di modifica, il nodeid del nodo uploader e la modificabilità. Avendo tutti i dati necessari ora il metodo get creerà un nuovo oggetto response, impostanto l'attributo tipo su ACK. A questo response aggiunge un campo file e a questo campo aggiunge gli attributi checksum, data creazione, data modifica, uploader, modificabilità e contenuto del file. Assegna a questi attributi i valori letti nel database e restituisce questo oggetto response al client.

Il client se la response è di tipo ACK procede alla lettura del campo file. Come prima cosa legge l'attributo checksum e lo paragona con quello che calcola dal frammento contenuto nell'oggetto response. Se combaciano aggiunge il frammento del file alla stringa fileContent. La stringa fileContent alla fine del ciclo for contiene tutto il file cifrato ricomposto. Quindi è pronta per essere decriptata tramite la chiave che all'inizio del metodo avevamo recuperato dal database. Decifrato il file sarà sufficiente inserirlo nell'oggetto response e restituirlo al terminale. Ora il terminale ha il file richiesto dall'utente. Lo script che abbiamo usato per i test stampa direttamente a schermo il contenuto, se vogliamo ottenere il file basterà indirizzare il risultato del comando in un file con quel nome.
\subsection{Share}
Il comando share permette di condividere la conoscenza di un determinato file con altri utenti. Come abbiamo visto nel comando put, quando un client salva in darkcloud un file questo viene spezzettato ed inviato ai server, dopo di che il client salva i dati necessari a ricomporlo in sicurezza. Per far si che anche un altro client possa recuperare quel file dobbiamo prendere i dati contenuti nel database del client che condivide e copiarli nel database del client con cui vogliamo condividere il file.
Quindi a differenza degli altri comandi che vedevano coinvolti un client e diversi server questa volta nel codice del comando share devono interagire due client. nel caso del put e del get avevamo la versione del comando per il client e quella per il server, questa volta invece il codice del comando share è contenuta solo nei metodi di risposta del client, cioè nella classe ClientResponseMethod. Però visto che la procedura di salvataggio deve essere fatta direttamente dal nodo ricevente, abbiamo creato un altro metodo, che si chiama receive. Un nodo non può salvare informazioni direttamente sul database di un altro nodo, sarebbe pessimo per la sicurezza. Quindi quando noi invochiamo il comando share dal nodo A verso il nodo B per condividere un file, il nodo A reperisce nel suo database le informazioni del file, e le invia al metodo receive del nodo B, che procede con il controllo dei dati e il salvataggio nel suo database.
La sintassi del comando è :

python client.py -r SHARE -h 'ip del client che condivide' -p 'porta del client che condivide' -F 'nome del file remoto' -H 'ip del ricevente' -P 'porta del ricevente'

Quando un utente vuole condividere con un altro la conoscenze di un file utilizza il suo terminale e il comando sopra scritto. Quando il terminale invia il messaggio al client, questo lo riceve tramite la classe ClientService e crea un istanza della classe CLient, la quale tradurrà il messaggio in un oggetto request. Riconosciuto che  l'oggetto request è di tipo share procederà ad invocare tale metodo passandogli i campi contenuti nel messaggio. Il metodo share procede al controllo dell'esistenza del campo sharing. Nel campo sharing sono contenuti tre attributi, secondhost, secondport e remotefile. Questi attributi sono stati attribuiti dal terminale con i campi specificati nella sintassi del comando share. Il codice prosegue controllando che a tutti gli attributi sia stato assegnato un valore. Fatto ciò si passa a leggere dal database i dati che riguardano il file. Dobbiamo prendere i file da due tabelle, FILE e FILEFRAGMENT. Per fare questo facciamo un join sul'attributo name che deve essere uguale al nome del file remoto specificato nel comando. I risultati verranno ordinati per fragmentid e i campi selezionati sono in ordine la chiave del file, il checksum del file intero, la data di creazione del file, il numero che identifica il frammento, il checksum del frammento e nodeid del server che conserva il frammento. 
Si passa ora a recuperare il NetNode corrispondente al client a cui dobbiamo inviare i dati. I NetNode sono identificati da un codice alfanumerico ottenibile dalla funzione getNodeKey della classe Darkcloud dando in ingresso l'indirizzo ip e la porta di ascolto del nodo. Ottenuto il nodeid possiamo procedere a copiare in locale l'oggetto NetNode del client a cui dobbiamo inviare i dati. Per ottenere questo oggetto usiamo il metodo Darkcloud.getIstance().getAliveClientNodes().get(nodeid) .
Come notate stiamo prendendo il NetNode dalla struttura dati dove sono salvati quelli segnati come vivi. Infatti anche i client proprio come i nodi server vengono contattati periodicamente per verificare che siano online. Il prossimo passo consiste nel preparare la chiave del file per il trasferimento. Quando noi abbiamo salvato la chiave simmetrica del file, nel metodo put, la abbiamo criptata con la nostra chiave pubblica. Ora dobbiamo decriptarla, con la nostra chiave privata e criptarla con la chiave pubblica del nodo a cui dobbiamo mandarla. Per decriptarla usiamo il metodo decrypt della classe Cryptutil, dandogli in ingresso la stringa che abbiamo preso nel database, la nostra chiave pubblica ottenibile con il metodo Darkcloud.getIstance().getPrivateKey(), e infine specificando il metodo di decriptazione cioè RSA. Il metodo decrypt ci restituisce un array di byte, che noi convertiamo in un oggetto SecretKey tramite il metodo della Cryptutil denominato secretKeyFromString. Questo passaggio è necessario in quanto il metodo per criptare accetta in ingresso come chiave solo un oggetto SecretKey. La chiave pubblica del nodo ricevente è salvata nel NetNode corrispondente che abbiamo recuperato, e per usarla basterà il metodo NetNode.getPubKey(). Fornendo la chiave simmetrica decriptata e la chiave pubblica del nodo ricevente al metodo encrypt otteniamo la chiave simmetrica criptata pronta per essere spedita. Ricordo che le stringhe passate tra i metodi e inserite nei messaggi devono essere codificate in base64 per evitare problemi di trasferimento. Ora dobbiamo preparare un oggetto request e inserirgli i valori da mandare al client ricevente. L'oggetto request è di tipo receive, ai nostri oggetti request o response possiamo aggiungere tutti i campi che vogliamo e nei campi possiamo inserire tutti gli attributi che vogliamo. In questo caso dobbiamo trasferire un insieme di informazioni che riguardano il file intero e un numero variabile di insiemi di informazioni che riguardano i frammenti. Per questo prima creiamo l'oggetto request, impostiamo il tipo come receive, vi creiamo un nuovo campo che chiameremo file nel quale andiamo ad inserire gli attributi che riguardano il file intero, che sono nome, chiave simmetrica, checksum, data di creazione e numero di frammenti. Ora, tramite un ciclo for che si ripete tante volte quanti sono i frammenti, andiamo a creare tanti campi quanti frammenti. Ogni campo si chiamerà fragment'i', dove i è il numero che identifica il frammento. Tramite il ciclo in ognuno di questi campi inseriremo come attributi i dati dei frammenti, che sono numero del frammento, checksum e l'identificativo nodeid del server dove si trova. Terminata la preparazione della request possiamo mandarla al client ricevente. Usiamo il metodo send dell'oggetto NetNode precedentemente recuperato. 
Il metodo send aprirà un socket SSL con l'altro client, e invierà il messaggio.

Il client ricevente tramite ClientService riceve il messaggio, crea un istanza di Client, la quale riconosce il tipo di request come receive. Invoca il metodo receive dalla classe ClientResponseMethod e gli passa la request.
Il metodo receive legge per primo l'attributo del campo file che contiene il numero dei frammenti. Poi imposta un ciclo for che legge i campi che contengono i dati dei frammenti e li salva nella tabella FILEFRAGMENT. Se tutti i frammenti vengono salvati il metodo receive procede con la lettura del campo file e salva nella tabella FILE i dati in esso contenuto. Se questi inserimenti avvengono con successo il metodo receive crea un oggetto response e gli attribuisce il tipo ACK che indica la corretta fine del metodo. Restituisce poi questa response al metodo Client che provvederà ad inviarla al client che ha fornito i dati.

Il client che ha inviato i dati riceve cosi la response positiva, e procede a sua volta a notificare al terminale che l'operazione è terminata con successo. Per farlo crea una response di tipo ACK e la restituisce al terminale tramite la classe Client. Il terminale da cui era partito il comando, in caso di ricezione del messaggio ACK stampa a schermo un messaggio che ci informa che il file è stato condiviso con il client specificato. 
\section{File di log}
Una cosa essenziale in ogni software è il file di log, tramite questo possiamo controllare il funzionamento del nostro nodo e verificare la presenza di errori o anomalie. In caso di errori possiamo verificare dove si sono verificati questi errori all'interno del software e da cosa sono stati scatenati. Maggiore è l'accuratezza e maggiori sono i dettagli riportati in un file di log maggiore sarà la velocità con la quale si capirà il problema e minore il tempo impiegato per risolverlo. Proprio per questo abbiamo utilizzato all'interno del nostro software un sistema di log molto articolato. Per farlo utilizziamo la classe Logger che fa parte del package org.apache.log4j . 
Log4j è un progetto Open Source dell’Apache Software Foundation (ASF) che permette di monitorare un’applicazione Java durante il suo utilizzo qualora non fosse possibile utilizzare strumenti di debugging, si pensi ad esempio quando una applicazione è distribuita sul web o è di tipo multithreading. Il logging ha però una controindicazione: porta ad un decremento delle performance. Per alleviare questo difetto, log4j è stato sviluppato per essere veloce ed estendibile, permettendo vari livelli di granularità nel controllo del logging. Il vantaggio più importante che ha un sistema di logging ha rispetto a riempire il nostro codice di System.out.println, è che è possibile controllare quando visualizzare gli statement di log. In altre parole è possibile dividere lo spazio dei log, che è lo spazio dove risiedono tutti gli statement di log, in categorie definite da criteri decisi dallo sviluppatore. La classe Logger rappresenta appunto uno spazio dei log che rispetta dei determinati criteri.
Infatti nella cartella principale del nostro nodo troviamo il dile darkcloud.log che contiene tutte le informazioni di cui nel codice abbiamo deciso di tener traccia. Sono divise in categorie quali Message, Config, Info ed Error. Inoltre in tali file di log vengono indirizzati i messaggi di errore che il sofware genera. 
Per ogni errore o per capire meglio il funzionamento del programma si invita l'utilizzatore a leggere il file di log.














